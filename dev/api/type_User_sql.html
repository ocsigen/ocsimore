<html><head><title></title><meta charset="utf8"/><meta content="width=device-width, initial-scale=1" name="viewport"/></head><body class="type_User_sql dev"><pre class=""><code class="language-ocaml translatable">sig
  module Types :
    sig
      type userid = [ `User ] Opaque.int32_t
      val userid_from_sql : int32 -&gt; User_sql.Types.userid
      val sql_from_userid : User_sql.Types.userid -&gt; int32
      val string_from_userid : User_sql.Types.userid -&gt; string
      type pwd =
          Connect_forbidden
        | Ocsimore_user_plain of string
        | Ocsimore_user_crypt of string
        | Ocsimore_user_safe of Bcrypt.hash_t
        | External_Auth
      type find_param = {
        param_description : string;
        param_get :
          unit -&gt;
          &lt; id : &lt; get : unit; nul : Sql.non_nullable; t : Sql.int32_t &gt;
                 Sql.t;
            title : &lt; get : unit; nul : Sql.nullable; t : Sql.string_t &gt;
                    Sql.t &gt;
          list Lwt.t;
        param_display : (int32 -&gt; string Lwt.t) option;
        find_param_functions :
          ((string -&gt; int32 Lwt.t) * (int32 -&gt; string Lwt.t)) option;
      }
      type userdata = {
        user_id : User_sql.Types.userid;
        user_login : string;
        user_pwd : User_sql.Types.pwd;
        user_fullname : string;
        user_email : string option;
        user_dyn : bool;
        user_kind :
          [ `BasicUser
          | `NonParameterizedGroup
          | `ParameterizedGroup of User_sql.Types.find_param option ];
      }
      type 'a parameterized_group
      val parameterized_group_from_userid :
        User_sql.Types.userid -&gt; 'a User_sql.Types.parameterized_group
      type user
      val apply_parameterized_group :
        'a User_sql.Types.parameterized_group -&gt;
        'a Opaque.int32_t -&gt; User_sql.Types.user
      val ( $ ) :
        'a User_sql.Types.parameterized_group -&gt;
        'a Opaque.int32_t -&gt; User_sql.Types.user
      val basic_user : User_sql.Types.userid -&gt; User_sql.Types.user
      val non_parameterized_group :
        User_sql.Types.userid -&gt; User_sql.Types.user
      val userid_from_user : User_sql.Types.user -&gt; User_sql.Types.userid
      val is_basic_user : User_sql.Types.user -&gt; User_sql.Types.userid option
      val user_is_applied_parameterized_group :
        user:User_sql.Types.user -&gt;
        pgroup:'a User_sql.Types.parameterized_group -&gt;
        'a Opaque.int32_t option
      type 'a admin_writer_reader = {
        grp_admin : 'a User_sql.Types.parameterized_group;
        grp_writer : 'a User_sql.Types.parameterized_group;
        grp_reader : 'a User_sql.Types.parameterized_group;
      }
      type users = {
        users : User_sql.Types.userdata list Lazy.t;
        groups : User_sql.Types.userdata list Lazy.t;
        roles : User_sql.Types.userdata list Lazy.t;
      }
    end
  exception NotAnUser
  val new_user :
    name:string -&gt;
    password:User_sql.Types.pwd -&gt;
    fullname:string -&gt;
    email:string option -&gt;
    dyn:bool -&gt; (User_sql.Types.userid * User_sql.Types.pwd) Lwt.t
  val new_parameterized_group :
    prefix:string -&gt;
    name:string -&gt;
    descr:string -&gt;
    find_param:User_sql.Types.find_param -&gt;
    'a User_sql.Types.parameterized_group Lwt.t
  val new_nonparameterized_group :
    prefix:string -&gt; name:string -&gt; descr:string -&gt; User_sql.Types.user Lwt.t
  exception NotBasicUser of User_sql.Types.userdata
  val get_basicuser_by_login : string -&gt; User_sql.Types.userid Lwt.t
  val get_basicuser_data :
    User_sql.Types.userid -&gt; User_sql.Types.userdata Lwt.t
  val get_parameterized_user_data :
    'a User_sql.Types.parameterized_group -&gt; User_sql.Types.userdata Lwt.t
  val get_user_data : User_sql.Types.user -&gt; User_sql.Types.userdata Lwt.t
  val groups_of_user :
    user:User_sql.Types.user -&gt; User_sql.Types.user list Lwt.t
  val users_in_group :
    ?generic:bool -&gt;
    group:User_sql.Types.user -&gt; User_sql.Types.user list Lwt.t
  val add_to_group :
    user:User_sql.Types.user -&gt; group:User_sql.Types.user -&gt; unit Lwt.t
  val remove_from_group :
    user:User_sql.Types.user -&gt; group:User_sql.Types.user -&gt; unit Lwt.t
  val add_generic_inclusion :
    subset:'a User_sql.Types.parameterized_group -&gt;
    superset:'a User_sql.Types.parameterized_group -&gt; unit Lwt.t
  val add_to_group_generic :
    user:'a User_sql.Types.parameterized_group -&gt;
    group:'a User_sql.Types.parameterized_group -&gt; unit Lwt.t
  val delete_user : userid:User_sql.Types.userid -&gt; unit Lwt.t
  val update_data :
    userid:User_sql.Types.userid -&gt;
    ?password:User_sql.Types.pwd -&gt;
    ?fullname:string -&gt;
    ?email:string option -&gt; ?dyn:bool -&gt; unit -&gt; unit Lwt.t
  val userid_to_string : User_sql.Types.userid -&gt; string Lwt.t
  val user_to_string :
    ?expand_param:bool -&gt; User_sql.Types.user -&gt; string Lwt.t
  val get_user_by_name : string -&gt; User_sql.Types.user Lwt.t
  val all_users : unit -&gt; User_sql.Types.users Lwt.t
  val user_type : User_sql.Types.user -&gt; [ `Group | `Role | `User ] Lwt.t
  type user_settings = {
    basicusercreation : bool;
    registration_mail_from : string;
    registration_mail_addr : string;
    registration_mail_subject : string;
    groups : string;
    non_admin_can_create : bool;
  }
  val get_users_settings : unit -&gt; User_sql.user_settings Lwt.t
  val set_users_settings : User_sql.user_settings -&gt; unit Lwt.t
  val get_users_login :
    unit -&gt;
    &lt; id : &lt; get : unit; nul : Sql.non_nullable; t : Sql.int32_t &gt; Sql.t;
      title : &lt; get : unit; nul : Sql.nullable; t : Sql.string_t &gt; Sql.t &gt;
    list Lwt.t
end</code></pre></body></html>
